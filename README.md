# Этюды для программистов. 

## Часть 1. Папочка, а почему море синее? или Раскрашивание карты методом исчерпывающего поиска

### Условие

Чтобы на географической карте было удобно различать регионы, ее раскрашивают по следующему правилу: два региона должны быть окрашены в разные цвета, если их границы имеют более чем конечное число общих точек. (Обычно составители карт не страдают топологическими патологиями и не ищут вырожденных примеров, противоречащих здравому смыслу.) С другой стороны, картографам предстоит оплачивать типографские счета, поэтому, чем меньше цветов будет использовано, тем лучше. В частности, картографы, расписывающие карту как попало, распишутся лишь в своем легкомыслии: им придется использовать больше красок, чем это необходимо. Свои действия нужно планировать заранее. Итак, задача о раскрашивании карты сводится, в сущности, к определению минимального числа красок.

Для решения этой задачи обратимся к помощи компьютера. Тут нас подстерегают трудности: большинство ЭВМ лишено зрения, поэтому они не могут посмотреть на карту; к счастью, им нужно знать лишь, какие регионы являются соседями, т. е. смежны друг другу. Размер и форма регионов не влияют на раскраску, важно лишь наличие нетривиальных контактов между ними. Для представления отношения смежности полезно воспользоваться неориентированным графом.

Неориентированный граф состоит из конечного множества вершин и конечного множества ребер, связывающих вершины. Любые две вершины связаны не более чем одним ребром; не должно быть двух дублирующих друг друга ребер; кроме того, для рассматриваемой задачи мы запрещаем ребру связывать вершину с самой собой. На рис. 3.1 изображен неориентированный граф, представляющий первые 49 американских штатов. Ввести граф в ЭВМ несложно: достаточно перечислить все вершины, сопроводив каждую списком смежных ей вершин. Граф может не иметь вершин, а значит, и ребер; такой граф называется пустым. Вершина может быть изолированной, если нет ребер, связывающих ее с другими вершинами (примером тому могли бы служить Аляска и Гавайи); точно так же две части графа окажутся изолированными друг от друга, если нет ребер, их связывающих. Аналогия между картами и неориентированными графами столь тесна, что мы будем использовать эти понятия как равнозначные. Ну, а польза, приносимая графами, столь велика, что всем программистам следует иметь представление об их основных свойствах. 

![Штаты Америки](<Штаты Америки.png>)

Рисунок 3.1. Топологическая карта Соединенных Штатов. Для нее достаточно четырех цветов. (WA — Вашингтон, OR — Орегон, CA — Калифорния, NV — Невада, ID — Айдахо, UT — Юта, AZ — Аризона, МТ — Монтана, WY — Вайоминг, СО — Колорадо, NM — Нью-Мексико, ND — Северная Дакота, SD — Южная Дакота, NE — Небраска, КА — Канзас, ОК — Оклахома, ТХ — Техас, MN — Миннесота, IA — Айова, МО — Миссури, AR — Арканзас, LA — Луизиана, WI — Висконсин, IL — Иллинойс, IN — Индиана, MS — Миссисипи, AL — Алабама, Ml — Мичиган, ОН — Огайо, KY — Кентукки, TN — Теннесси, GA — Джорджия, FL — Флорида, РА — Пенсильвания, WV — Западная Виргиния, VA — Виргиния, NC — Северная Каролина, SC — Южная Каролина, NY — Нью-Йорк, NJ — Нью-Джерси, DE — Делавэр, MD — Мэриленд, DC — округ Колумбия, VT — Вермонт, МА — Массачусетс, СТ — Коннектикут, WE — Мэн, NH — Нью-Гэмпшир, RI — Род-Айленд.) 

### Тема

Напишите программу, раскрашивающую карту в минимальное число цветов. Исходными данными служит список регионов с указанием соседей каждого региона. Результатом должен быть список регионов с приписанными им цветами и общее число использованных цветов. Обычно проще всего для обозначения регионов и цветов применить положительные числа, но куда приятнее (и полезнее для отладки), если допускается ввод более привычных названий. Исходные данные должны проверяться на непротиворечивость; выявляйте нелепые номера вершин и связанные с собой вершины. Постарайтесь сделать программу по возможности эффективной, иначе раскраска тяжелых случаев окажется для вас слишком дорогим удовольствием. 

### Указания исполнителю

Исходная карта не обязана быть планарной. В самом деле, вполне допустимыми крайними случаями служат карты, в которых любые два региона — соседи, и карты, в которых никакие два региона не являются соседями. Последний случай соответствует раскраске множества раздельных шаров, когда достаточно только одного цвета. Проверка планарности — важная тема информатики, ей посвящено немало статей. Возможно, вас заинтересует проверка гипотезы о четырех красках, утверждающей, что для любой планарной карты требуется не более четырех красок. Если вам удастся подтвердить или опровергнуть ее, вы сделаете себе имя. [Теперь это замечание имеет лишь исторический интерес. Теорема была доказана в 1976 году. Правда, потом опровергнута. А затем доказана с помощью компьютера. Но чисто математического доказательства все ещё нет Прим. iReset].

Из ресурсов, требуемых данной задачей, самый важный — время. Конечно, нет смысла перебирать все возможные решения, поскольку их число быстро увеличивается с ростом числа регионов, а доля правильных решений (даже если таковых несколько) мала. Лучше воспользоваться методом перебора с возвратами. Начните с выбора некоторого региона и приписывания ему цвета. В дальнейшем переходите к соседнему нераскрашенному региону и пытайтесь приписать ему какой-нибудь из использованных цветов, совместимый с уже сделанной раскраской. (Может случиться, что раскрашивать больше нечего, тогда задача решена. Возможен и случай, когда не осталось нераскрашенных регионов, соседних с раскрашенными, т. е. попалась несвязная карта.) Если в некоторый момент новый регион не удается раскрасить, отступайте от уже раскрашенных регионов (в соответствии с порядком раскраски) до тех пор, пока не найдется регион, цвет которого можно изменить. Раскрасьте его в цвет, которого он ранее не имел, и снова продвигайтесь вперед. Если при отступлении вы возвратились в регион, раскрашенный первым, добавьте к своей палитре новый цвет и начните сначала. 

### Инструментовка

Для решения задачи достаточно таких структур данных, как массивы и стеки, поэтому годится почти любой алгебраический язык высокого уровня с подходящими управляющими структурами. (Попытки записи решения на Фортране или Бейсике должны показать скудость этих языков.) С другой стороны, перебор с возвратами выглядит элегантно в рекурсивной формулировке. Поэтому, возможно, полезным окажется язык с рекурсивными процедурами. И рекурсия, и подходящие структуры данных имеются в языке Лисп. 

### Литература

- **Битнер, Рейнгольд (Bitner J. R., Reingold E. M.). Backtrack Programming Techniques. С ACM, 18, 11, pp. 651–656, November 1975.**

Эта статья — очень краткое руководство по программированию методом перебора с возвратами. Но если приведенных авторами примеров окажется недостаточно, чтобы вы поняли суть метода, к вашим услугам обширная библиография по проблемам, которые решены методом перебора с возвратами или которые целесообразно этим методом решать.

- **Ope (Ore О.). The Four Color Problem. Academic Press, New York, 1967.**

В книге дан обзор математических вопросов, связанных с гипотезой четырех красок. По ней можно ознакомиться со многими разделами теории графов; можно почерпнуть и способ ускорения перебора с возвратами. Но не пытайтесь найти в книге быстрого алгоритмического решения.

- **Ершов А. П. Введение в теоретическое программирование. — М.: Наука, 1977.**

- **Абрамов С. А. Математические построения и программирование. М.: Наука, 1978.**

- **Харари Ф. Теория графов, гл. 12. Пер. с англ. — М.: Мир, 1973.**

- **[Статья "Зачем студентам теория графов" на Хабре](https://habr.com/ru/articles/570970/)**

- **[Статья "Алгоритм backtracking" на Хабре](https://habr.com/ru/companies/otus/articles/746408/)**

- **[Статья "Проблема четырех красок" на КиберЛенинке](https://cyberleninka.ru/article/n/problema-chetyreh-krasok/viewer)**

- **[Статья "Теорема о четырех цветах: раскраска карт, теория графов и консерватизм математического сообщества" на Хабре](https://habr.com/ru/companies/itglobalcom/articles/750062/)**

- **[Курс "Ликбез по дискретной математике" на Stepik](https://stepik.org/course/91/promo)**

- **Кормен Т. Алгоритмы: построение и анализ. 3-е изд.**

- **Дистель Р. Теория графов**

- **Хаггарти Р. Дискретная математика для программистов**

- **Оре О. Графы и их применение**

### Структура программы

1. InputHandler.h
    - Класс InputHandler: чтение и парсинг входных данных
      - `static Graph readFromFile(const std::string& filename)` — загрузка данных из файла.
      - `static Graph readFromConsole()` — ввод данных через консоль.

2. OutputHandler.h
    - Класс OutputHandler: Вывод результатов раскраски.
      - `static void printToConsole(const std::unordered_map<std::string, int>& colorAssignment, int colors)` — вывод в консоль.
      - `static void writeToFile(const std::string& filename, const std::unordered_map<std::string, int>& colorAssignment, int colors)` — запись в файл.

3. Graph.h
    - Класс Graph: Хранение структуры графа и проверка его корректности.
      - `void addRegion(const std::string& region)` — добавление региона.
      - `void addEdge(const std::string& region1, const std::string& region2)` — добавление ребра между регионами с проверкой на петли и дубликаты.
      - `const std::vector<std::string>& getNeighbors(const std::string& region)` — получение списка соседей региона.
      - `bool validate()` — проверка корректности графа (отсутствие петель и дублирующих ребер).
      - `size_t size() const` — возвращает количество регионов.

4. ColoringAlgorithm.h
    - Класс ColoringAlgorithm: Реализация алгоритма раскраски графа методом перебора с возвратами.
      - `void run()` — запуск алгоритма (определяет порядок регионов и запускает backtrack).
      - `int getMinColors() const` — возвращает минимальное количество цветов.
      - `const std::unordered_map<std::string, int>& getColorAssignment() const` — возвращает раскраску.

5. Test.h
   - Класс Test: Набор тестов для отладки алгоритма

### Особенности

Добавлено логирование в программу. Каждое изменение цвета региона записывается в файл `log.txt`. Запуск нового раскрашивания стирает его содержимое.